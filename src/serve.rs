// ###################################
// ->   SERVE
// ###################################
use crate::app::App;
use crate::fallback::static_file_and_err_handler;

use axum::{body::Body, middleware, Router};
use http::{HeaderName, Request, Response};
use leptos::LeptosOptions;
use leptos_axum::LeptosRoutes;
use leptos_router::RouteListing;
use std::time::Duration;
use tokio::net::TcpListener;
use tower::ServiceBuilder;
use tower_http::{
    classify::ServerErrorsFailureClass,
    request_id::{MakeRequestUuid, PropagateRequestIdLayer, SetRequestIdLayer},
    trace::TraceLayer,
};
use tracing::Span;

const REQUEST_ID_HEADER: &str = "x-request-id";

/// SERVE
/// The core async function returning a future that will serve this application.
///
/// Accepts a "TcpListener", `routes` generated by Leptos and the `state`(currently only `LeptosOptions`) and creates an App Router.
/// It sets up a TraceLayer that provides console logging.
/// It returns a `Result` containing a `Serve` future. Needs to be awaited like so:
/// ```ignore
/// maj_leptos::serve(listener, routes, leptos_options).await?;
/// ```
pub async fn serve(
    listener: TcpListener,
    routes: Vec<RouteListing>,
    state: LeptosOptions,
) -> Result<(), Box<dyn std::error::Error>> {
    let x_request_id = HeaderName::from_static(REQUEST_ID_HEADER);

    let trace_layer = TraceLayer::new_for_http()
        .make_span_with(|req: &Request<Body>| {
            let uuid = req
                .headers()
                .get(REQUEST_ID_HEADER)
                .map(|uuid| uuid.to_str().unwrap_or("").to_string());

            tracing::info_span!("req", id = uuid)
        })
        .on_response(|res: &Response<Body>, latency: Duration, _s: &Span| {
            let st_code = res.status();
            tracing::info!("END in: {:?} STATUS: {st_code}", latency)
        })
        .on_request(|req: &Request<Body>, _s: &Span| {
            tracing::info!("START: {} @ {}", req.method(), req.uri().path(),)
        })
        .on_failure(
            |err: ServerErrorsFailureClass, latency: Duration, _s: &Span| {
                tracing::error!("ERROR: {err:?} â€” latency: {:?}", latency)
            },
        );

    // build our application with a route
    let app = Router::new()
        .leptos_routes(&state, routes, App)
        .route("/health-check", axum::routing::get(health))
        .layer(
            // Adding tower_http services (except CompressionLayer)
            ServiceBuilder::new()
                // Set UUID per request
                .layer(SetRequestIdLayer::new(
                    x_request_id.clone(),
                    MakeRequestUuid,
                ))
                // Tracing Layer
                .layer(trace_layer)
                // Propagate UUID to response, keep it last so it processes the response first!
                .layer(PropagateRequestIdLayer::new(x_request_id)),
        )
        .fallback(static_file_and_err_handler)
        // Set the compression layer for ALL routes
        .layer(tower_http::compression::CompressionLayer::new())
        .layer(middleware::from_fn(
            midware::if_modified_to_extensions_midware,
        ))
        .layer(middleware::map_response(midware::response_mapper_midware))
        .with_state(state);

    axum::serve(listener, app).await?;

    Ok(())
}

async fn health() -> axum::http::StatusCode {
    http::StatusCode::OK
}

mod midware {
    use std::ops::{Deref, DerefMut};

    use axum::{extract::Request, middleware::Next, response::Response};
    use chrono::{DateTime, TimeZone, Utc};
    use http::{
        header::{CACHE_CONTROL, IF_MODIFIED_SINCE, LAST_MODIFIED, VARY},
        StatusCode,
    };
    use tracing::debug;

    #[derive(Clone)]
    struct IfModifiedSince(DateTime<Utc>);
    impl Deref for IfModifiedSince {
        type Target = DateTime<Utc>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl DerefMut for IfModifiedSince {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }

    /// Tries to find `If-modified-since` header, if it finds the header it stores it in the Response
    /// extensions so that it can be handled by the response mapper.
    pub async fn if_modified_to_extensions_midware(req: Request, next: Next) -> Response {
        let modified = req.headers().get(IF_MODIFIED_SINCE).cloned();

        let mut response = next.run(req).await;

        if let Some(modified) = modified {
            if let Ok(modified) = modified.to_str() {
                if let Some(dt) = get_datetime_utc(modified) {
                    response.extensions_mut().insert(IfModifiedSince(dt));
                }
            }
        }
        response
    }

    pub async fn response_mapper_midware(res: Response) -> Response {
        let mut resp = res;

        // Detect and Handle `If-modified-since` header if possible
        let if_modified_since = resp.extensions().get::<IfModifiedSince>();
        if let Some(if_modified_since) = if_modified_since {
            if let Some(last_modified_header) = resp.headers().get(LAST_MODIFIED).cloned() {
                if let Some(last_modified) =
                    get_datetime_utc(last_modified_header.to_str().unwrap_or_default())
                {
                    debug!("If-modified-since: {}", **if_modified_since);
                    debug!("Last-modified: {}", last_modified);

                    if **if_modified_since > last_modified {
                        resp = Response::default();
                        *resp.status_mut() = StatusCode::NOT_MODIFIED;
                        // Add headers into the response
                        resp.headers_mut()
                            .insert(VARY, "accept-encoding".parse().unwrap());
                        resp.headers_mut()
                            .insert(LAST_MODIFIED, last_modified_header);
                    }
                }
            }
        }

        // Add `Cache-control` header
        debug!("Adding cache control header");
        if cfg!(debug_assertions) {
            resp.headers_mut().insert(
                CACHE_CONTROL,
                "no-store, no-cache, must-revalidate, proxy-revalidate"
                    .parse()
                    .unwrap(),
            );
        } else {
            resp.headers_mut().insert(
                CACHE_CONTROL,
                "max-age=3600, must-revalidate".parse().unwrap(),
            );
        }

        resp
    }

    /// Creates a `DateTime<Utc>` from `If-modified-since` or `Last-modified` header values.
    fn get_datetime_utc(input: &str) -> Option<DateTime<Utc>> {
        static MONTHS: [&str; 12] = [
            "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
        ];

        let regex = lazy_regex::regex_captures!(
            r#"\s*(\w{3}),\s*(\d{2})\s*(\w{3})\s*(\d{4})\s*(\d{2}):(\d{2}):(\d{2})\s*GMT"#,
            input
        );

        let (_full_input, _day_str, day, month, year, hour, min, sec) = regex?;
        let day: u32 = day.parse().ok()?;
        let month = MONTHS
            .iter()
            .enumerate()
            .find(|(_i, &m)| m == month)
            .map(|(i, _)| i + 1)? as u32;
        let year: i32 = year.parse().ok()?;
        let hour: u32 = hour.parse().ok()?;
        let min: u32 = min.parse().ok()?;
        let sec: u32 = sec.parse().ok()?;

        let date_time = match Utc.with_ymd_and_hms(year, month, day, hour, min, sec) {
            chrono::offset::LocalResult::Single(res) => res,
            chrono::offset::LocalResult::Ambiguous(_early, latest) => latest,
            chrono::offset::LocalResult::None => return None,
        };

        Some(date_time)
    }
}
